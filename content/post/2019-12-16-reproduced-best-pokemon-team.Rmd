---
title: '[Adapted] Best Pokemon Team'
author: yjtek
date: '2019-12-16'
slug: reproduced-best-pokemon-team
categories: []
tags: []
draft: false
---

<style type="text/css">
<!-- body, td { -->
<!--    font-size: 14px; -->
<!-- } -->
<!-- code.r{ -->
<!--   font-size: px; -->
<!-- } -->
pre {
  font-size: 15px
}
p.caption {
  font-size: 13px;
  color: grey;
  font-style: italic;
  text-align: center;
}
</style>

```{r, echo = F, include = F}
library(tidyverse)
library(gridExtra)
library(kableExtra)
options(kableExtra.html.bsTable = T)
```

*Adapted from [Emily Robinson](https://hookedondata.org/pokemon-type-combinations/). Data from [robinsones](https://github.com/robinsones/pokemon-chart/blob/master/chart.csv).*
<br>
<br>

### Introduction

Came across this fairly interesting blog post recently. Given that there are 18 types of pokemon, some of which are super-effective/not very effective against each other, how do we get a pokemon team combination that is super effective against most other teams?

```{r, echo = F}
chart <- read.csv('../../static/data/2019-12-16-reproduced-best-pokemon-team_files/chart.csv')
head(chart)
```

We take in a base dataset showing the effects from each 18*18 attack/defence pair. 0.5 indicates a not very effective attack, 1 indicates a normal attack, and 2 indicates a super effective attack. 

### Basic analysis

We can already draw some basic aggregate conclusions about the most useful types by maximising the attack dealt and minimising the attack received.

```{r}
mostUsefulAttack <- data.frame(type = chart$Attacking, `Attack Dealt` = rowSums(chart[,2:ncol(chart)]))
mostUsefulDefence <- data.frame(type = colnames(chart)[2:ncol(chart)], `Attack Received` = colSums(chart[, 2:ncol(chart)]))
mostUseful <- mostUsefulAttack %>% left_join(mostUsefulDefence, by = 'type')
mostUseful
```

The baseline for both scores is 18 (i.e. you deal normal damage to all other types, and take normal damage from all other types). A cursory analysis will already tell us which types are most useful. If we are willing to ignore the distribution of the scores, we can simply find all types where attack dealt exceeds the baseline, and the attack received is below the baseline.

```{r}
mostUseful %>%
  filter(Attack.Dealt >= 18 & Attack.Received <= 18)
```

### Maximising super-effectiveness

As marvellous as that sounds, we clearly don't fight pokemon in some weird aggregated group fight. Pokemon fights are a 1v1 affair, and it follows that the analysis should be conducted at the type pair level. Using [Emily Robinson's](https://hookedondata.org/pokemon-type-combinations/) work, we sharpen the granularity of the analysis to see which types provide the most "super effective" attacks.

```{r}
chartLong <- chart %>%
  pivot_longer(-Attacking, names_to = 'Defending', values_to = 'Attack Effectiveness') %>%
  mutate(`Attack Effectiveness` = if_else(`Attack Effectiveness` == 2, 1, 0)) %>%
  group_by(Attacking) %>%
  summarise(`Count Attack Super Effective` = sum(`Attack Effectiveness`)) %>%
  arrange(desc(`Count Attack Super Effective`))
head(chartLong)
```

To form the best combination of 6, and lacking some sort of prior about what that combination should be, we rely on good old fashioned brute forcing. Using `combn()`, we get a dataframe where every column is 1 combination.

```{r}
combinations <- combn(18,6)
dim(combinations)
```

Using the base dataframe, we change the values such that super effective attacks are reflected as 1s in the matrix, and everything else is reflected as 0.

```{r}
m <- as.matrix(chart[, -1])
rownames(m) <- chart$Attacking
super_effective_m <- (m == 2) * 1L
head(super_effective_m)
```

Now we have an 18x18 matrix with 1s where attacks are super effective, a 6x18564 matrix of possible combinations of 6 pokemon teams.^[$\frac{18!}{12! \cdot 6!} = 18564$]. To work with this, we define a function that takes in each combination of pokemon types (every row of `combination`), and sums the number of types the combination is super effective against. 

```{r}
super_effective_nb <- function(indices){
  #for each pokemon group (6-row-subset of super_effective_m), take the column sum for each of the 18 columns. If colSums > 0, then there is at least 1 of the 6 types that is super effective, so count this as a 1. Sum all types your group is super effective against.
  sum(colSums(super_effective_m[indices, ]) > 0)
}
super_effective_results <- apply(combinations, 2, super_effective_nb)
best_combos <- combinations[, super_effective_results == max(super_effective_results)]
strongest_teams <- matrix(rownames(super_effective_m)[best_combos], nrow = 6)
strongest_teams %>%
  data.frame() %>%
  mutate(count = 1:6) %>%
  pivot_longer(-count, names_to = 'group', values_to = 'type') %>%
  select(-count) %>%
  group_by(type) %>%
  summarise(count = length(unique(group))) %>%
  arrange(desc(count))
```

We can now see the pokemon types that are needed for the maximum possible super-effective team combination. (you cannot run away from having a ground type)

### Equilibrium

Let's assume this whole exercise is correct up to this point (ignore distribution of super-effective attacks, super-effective attacks worth 4x normal attacks, etc.). If we assume that this "optimal" response will be played, is the Nash equilibrium to reply with this? response as well? For illustration, I will just use the first group identified

```{r}
# Picking one of 10 the strongest combinations:
strongestTeamIndex <- unique(row(super_effective_m)[rownames(super_effective_m) %in% strongest_teams[,1]])
super_effective_m[,strongestTeamIndex]
```

```{r}
super_effective_nb_subset <- function(indices){
    sum(colSums(super_effective_m[indices, strongestTeamIndex]) > 0)
}
super_effective_results_subset <- apply(combinations, 2, super_effective_nb_subset)
best_combos_subset <- combinations[, super_effective_results_subset == max(super_effective_results_subset)]
dim(best_combos_subset)
```

Clearly, when you have a fixed team of only 6 to counter, there are a lot more possible "optimal" combinations. The point is to see if you have the optimal 10 among the 396 combinations identified.

```{r}
subset <- t(best_combos_subset) %>%
  as.data.frame() %>%
  unite('string', V1:V6)
optimal <- t(best_combos) %>%
  as.data.frame() %>%
  unite('string', V1:V6)
  
optimal$string %in% subset$string
```

All 10 appear in the subset! Which suggests that, ceteris paribus, it is always better to choose among the 10 optimal strategies identified above that maximise super effective attacks when responding to a `c(Electric, Ice, Fighting, Ground, Flying, Ghost)` team. 